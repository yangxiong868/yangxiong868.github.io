<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ double小数精度控制]]></title>
    <url>%2F2018%2F10%2F21%2FC-double%E5%B0%8F%E6%95%B0%E7%B2%BE%E5%BA%A6%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[C++ double小数精度控制1234567891011121314151617#include &lt;iomanip&gt;#include &lt;iostream&gt;template &lt;typename T&gt;T round(T number, int precision) &#123; std::stringstream ss; ss &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision) &lt;&lt; number; ss &gt;&gt; number; return number;&#125;int main() &#123; double number = 3.1415926535897932; cout &lt;&lt; "precision 4, number: " &lt;&lt; round(number, 4) &lt;&lt; endl; cout &lt;&lt; "precision 6, number: " &lt;&lt; round(number, 6) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GeoHash算法介绍]]></title>
    <url>%2F2018%2F10%2F21%2FGeoHash%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[GeoHash IntroductionGeoHash将二维的经纬度转换成字符串，比如下图展示了北京9个区域的GeoHash字符串，分别是WX4ER，WX4G2、WX4G3等等，每一个字符串代表了某一矩形区域。也就是说，这个矩形区域内所有的点（经纬度坐标）都共享相同的GeoHash字符串，这样既可以保护隐私（只表示大概区域位置而不是具体的点），又比较容易做缓存，比如左上角这个区域内的用户不断发送位置信息请求餐馆数据，由于这些用户的GeoHash字符串都是WX4ER，所以可以把WX4ER当作key，把该区域的餐馆信息当作value来进行缓存，而如果不使用GeoHash的话，由于区域内的用户传来的经纬度是各不相同的，很难做缓存。 GeoHash Algorithm下面以北海公园为例介绍GeoHash算法的计算步骤 根据经纬度计算GeoHash二进制编码地球纬度区间是[-90,90]， 北海公园的纬度是39.928167，可以通过下面算法对纬度39.928167进行逼近编码: 区间[-90,90]进行二分为[-90,0),[0,90]，称为左右区间，可以确定39.928167属于右区间[0,90]，给标记为1； 接着将区间[0,90]进行二分为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，给标记为0； 递归上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167； 如果给定的纬度x（39.928167）属于左区间，则记录0，如果属于右区间则记录1，这样随着算法的进行会产生一个序列1011100，序列的长度跟给定的区间划分次数有关。根据纬度算编码 bit min mid max 1 -90.000 0.000 90.000 0 0.000 45.000 90.000 1 0.000 22.500 45.000 1 22.500 33.750 45.000 1 33.7500 39.375 45.000 0 39.375 42.188 45.000 0 39.375 40.7815 42.188 0 39.375 40.07825 40.7815 1 39.375 39.726625 40.07825 1 39.726625 39.9024375 40.07825 同理，地球经度区间是[-180,180]，可以对经度116.389550进行编码。 二进制组码通过上述计算，纬度产生的编码为10111 00011，经度产生的编码为11010 01011。偶数位放经度，奇数位放纬度，把2串编码组合生成新串：11100 11101 00100 01111。 最后使用用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，首先将11100 11101 00100 01111转成十进制，对应着28、29、4、15，十进制对应的编码就是wx4g。同理，将编码转换成经纬度的解码算法与之相反，具体不再赘述。 GeoHash代码GeoHash CPP API本Geohash lib库的编解码函数介绍。GeoHash经纬度到字符串的编码函数：1bool Encode(double latitude, double longitude, uint32 precision, std::string* geohash); GeoHash字符串到经纬度的解码函数：1bool Decode(const std::string&amp; geohash, double* latitude, double* longitude); GeoHash 各语言代码 C/C++代码https://github.com/simplegeo/libgeohashhttps://github.com/windoze/geohash-cpp Python代码https://pypi.org/project/Geohash/#fileshttps://github.com/transitland/mapzen-geohash/blob/master/mzgeohash/geohash.py Java代码https://blog.csdn.net/sunrise_2013/article/details/42395261 Go代码https://github.com/mmcloughlin/geohash 参考资料GeoHash维基百科GeoHash核心原理解析GeoHash演示]]></content>
      <categories>
        <category>算法</category>
        <category>空间索引</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brpc json和protobuf双向转换]]></title>
    <url>%2F2018%2F10%2F20%2FBrpc-json%E5%92%8Cprotobuf%E5%8F%8C%E5%90%91%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[json2pb介绍brpc支持json和protobuf间的双向转化，实现于json2pb。 json2pb接口json2pb提供json到protobuf接口函数：JsonToProtoMessage，包含头文件：&lt;json2pb/json_to_pb.h&gt;，下面列举一个接口定义如下：1234bool JsonToProtoMessage(const std::string&amp; json, google::protobuf::Message* message, const Json2PbOptions&amp; options, std::string* error = NULL); json2pb提供protobuf到json接口函数：ProtoMessageToJson，包含头文件：&lt;json2pb/pb_to_json.h&gt;，下面列举一个接口定义如下：1234bool ProtoMessageToJson(const google::protobuf::Message&amp; message, std::string* json, const Pb2JsonOptions&amp; options, std::string* error = NULL); json2pb应用brpc json2pb的接口应用示例如下，addressbook.proto在brpc源码test文件中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;gflags/gflags.h&gt;#include &lt;glog/logging.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;json2pb/json_to_pb.h&gt;#include &lt;json2pb/pb_to_json.h&gt;#include "ads/serving/Json/addressbook.pb.h"#include "butil/iobuf.h"using addressbook::AddressBook;using addressbook::Person;void PopulateAddressBookMessage(AddressBook* address_book) &#123; Person* person = address_book-&gt;add_person(); person-&gt;set_id(100); person-&gt;set_name("Test"); person-&gt;set_data(-240000000); person-&gt;set_data32(6); person-&gt;set_data64(-1820000000); person-&gt;set_datadouble(123.456); person-&gt;set_datadouble_scientific(1.23456789e+08); person-&gt;set_datafloat_scientific(1.23456789e+08); person-&gt;set_datafloat(8.6123); person-&gt;set_datau32(60); person-&gt;set_datau64(960); person-&gt;set_databool(0); person-&gt;set_databyte("welcome to china"); person-&gt;set_datafix32(1); person-&gt;set_datafix64(666); person-&gt;set_datasfix32(120); person-&gt;set_datasfix64(-802);&#125;bool JsonToProtoMessageTest(const butil::IOBuf input, google::protobuf::Message* message) &#123; std::string error; json2pb::Json2PbOptions options; options.base64_to_bytes = true; butil::IOBufAsZeroCopyInputStream stream(input); if (!json2pb::JsonToProtoMessage(&amp;stream, message, options, &amp;error)) &#123; LOG(ERROR) &lt;&lt; "Failed to JsonToProtoMessage err:" &lt;&lt; error; return false; &#125; return true;&#125;bool ProtoMessageToJsonTest(const google::protobuf::Message&amp; message, butil::IOBuf* output) &#123; std::string error; json2pb::Pb2JsonOptions options; options.enum_option = json2pb::OUTPUT_ENUM_BY_NUMBER; options.bytes_to_base64 = true; butil::IOBufAsZeroCopyOutputStream stream(output); if (!json2pb::ProtoMessageToJson(message, &amp;stream, options, &amp;error)) &#123; LOG(ERROR) &lt;&lt; "Failed to ProtoMessageToJson err:" &lt;&lt; error; return false; &#125; return true;&#125;void Json2PbTest() &#123; bool result; butil::IOBuf buf; // ProtoMessageToJsonTest LOG(ERROR) &lt;&lt; "ProtoMessageToJsonTest......"; AddressBook address_book; PopulateAddressBookMessage(&amp;address_book); LOG(ERROR) &lt;&lt; "ProtoBuf:" &lt;&lt; address_book.DebugString(); result = ProtoMessageToJsonTest(address_book, &amp;buf); LOG(ERROR) &lt;&lt; "result: " &lt;&lt; result &lt;&lt; " Json:" &lt;&lt; buf; // ProtoMessageToJsonTest LOG(ERROR) &lt;&lt; "JsonToProtoMessageTest......"; AddressBook address_book1; result = JsonToProtoMessageTest(buf, &amp;address_book1); LOG(ERROR) &lt;&lt; "result: " &lt;&lt; result &lt;&lt; "ProtoBuf:" &lt;&lt; address_book1.DebugString();&#125;int main(int argc, char* argv[]) &#123; google::InitGoogleLogging(argv[0]); FLAGS_logtostderr = 1; Json2PbTest(); return 0;&#125; 程序运行结果如下：1234567891011121314151617181920212223242526272829303132333435363738394041E1019 16:09:41.195989 26059 json2pb_test.cpp:73] ProtoMessageToJsonTest......E1019 16:09:41.196545 26059 json2pb_test.cpp:76] ProtoBuf:person &#123; name: &quot;Test&quot; id: 100 data: -240000000 data32: 6 data64: -1820000000 datadouble: 123.456 datafloat: 8.6123 datau32: 60 datau64: 960 databool: false databyte: &quot;welcome to china&quot; datafix32: 1 datafix64: 666 datasfix32: 120 datasfix64: -802 datafloat_scientific: 1.2345679e+08 datadouble_scientific: 123456789&#125;E1019 16:09:41.196682 26059 json2pb_test.cpp:78] result: 1 Json:&#123;&quot;person&quot;:[&#123;&quot;name&quot;:&quot;Test&quot;,&quot;id&quot;:100,&quot;data&quot;:-240000000,&quot;data32&quot;:6,&quot;data64&quot;:-1820000000,&quot;datadouble&quot;:123.456,&quot;datafloat&quot;:8.612299919128418,&quot;datau32&quot;:60,&quot;datau64&quot;:960,&quot;databool&quot;:false,&quot;databyte&quot;:&quot;d2VsY29tZSB0byBjaGluYQ==&quot;,&quot;datafix32&quot;:1,&quot;datafix64&quot;:666,&quot;datasfix32&quot;:120,&quot;datasfix64&quot;:-802,&quot;datafloat_scientific&quot;:123456792.0,&quot;datadouble_scientific&quot;:123456789.0&#125;]&#125;E1019 16:09:41.196696 26059 json2pb_test.cpp:81] JsonToProtoMessageTest......E1019 16:09:41.196838 26059 json2pb_test.cpp:84] result: 1ProtoBuf:person &#123; name: &quot;Test&quot; id: 100 data: -240000000 data32: 6 data64: -1820000000 datadouble: 123.456 datafloat: 8.6123 datau32: 60 datau64: 960 databool: false databyte: &quot;welcome to china&quot; datafix32: 1 datafix64: 666 datasfix32: 120 datasfix64: -802 datafloat_scientific: 1.2345679e+08 datadouble_scientific: 123456789&#125; 参考链接1.brpc json2pb 介绍2.brpc json2pb 源码]]></content>
      <categories>
        <category>Brpc</category>
      </categories>
      <tags>
        <tag>Brpc</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶-JSON编码和解码]]></title>
    <url>%2F2018%2F03%2F24%2FPython%E8%BF%9B%E9%98%B6-JSON%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Python的JSON模块JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。Python内置类型和JSON数据类型的对应如下：| Python类型 | JSON类型 || :————— | :——– || dict | object{} || list, tuple | array[] || str, unicode | string || int, long, float | number || True | true || False | false || None | null | JSON编码json.dumps 用于将 Python 对象编码成 JSON 字符串。语法1json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding="utf-8", default=None, sort_keys=False, **kw) 如果ensure_ascii为true（默认值），则输出将保证所有传入的非ASCII字符都转义。如果ensure_ascii为false，则这些字符将按原样输出。 如果indent是非负整数或字符串，那么JSON数组元素和对象成员将以该缩进级别打印。缩进级别0，负数或””将只插入换行符。None（默认值）选择最紧凑的表示。使用正整数缩进缩进，每个级别有许多空格。 如果sort_keys为真（默认值：False），则字典的输出将按键排序。 实例以下实例将数组编码为 JSON 格式数据：1234567#!/usr/bin/pythonimport jsondata = &#123; 'a' : 1, 'b' : 2.0, 'c' : False, 'd' : True, 'e' : None, 'f' : [1, 2, 'str']&#125; json = json.dumps(data)print json 以上代码执行结果为：1&#123;"a": 1, "c": false, "b": 2.0, "e": null, "d": true, "f": [1, 2, "str"]&#125; 使用参数让 JSON 数据格式化输出：1234567#!/usr/bin/pythonimport jsondata = &#123;"foo" : 1, "bar" : 2&#125;json = json.dumps(data, sort_keys=True, indent=4, separators=(',', ': '))print json 以上代码执行结果为：1234&#123; "bar": 2, "foo": 1&#125; JSON解码json.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型。语法1json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]]) 第一步：将json文本转换为python数据结构第二步：按照操作字典的方法取值，取值之前先检查key和类型正确 实例以下实例展示了Python 如何解码 JSON 对象：1234567#!/usr/bin/python import jsonjsonData = '&#123;"a":1,"b":2,"c":3,"d":4,"e":5&#125;';text = json.loads(jsonData)print text 以上代码执行结果为：1&#123;u'a': 1, u'c': 3, u'b': 2, u'e': 5, u'd': 4&#125; 以下实例展示了Python 解码 JSON 对象后检查key和操作字典：1234567891011121314151617181920212223242526#!/usr/bin/pythonimport jsondef check_json_field(value, key): if not value.has_key(key): #检查key是否存在 print("Invalid json missing key %s" % key) return False if not isinstance(value[key], dict): #检查key的value类型 print("Invalid json invalid key %s" % key) return False return Truedef main(): jsonData = '&#123;"test":&#123;"a":1,"b":2.0,"c":false,"d":null,"e":"string"&#125;&#125;'; text = json.loads(jsonData) print text if check_json_field(text, "test") is True: test = text.get("test") print("a=%d, b=%d, c=%d, d=%s, e=%s" % \ (test.get("a"), test.get("b"), test.get("c"), test.get("d"), test.get("e")))if __name__ == "__main__": main() 以上代码执行结果为：12&#123;u'test': &#123;u'a': 1, u'c': False, u'b': 2.0, u'e': u'string', u'd': None&#125;&#125;a=1, b=2, c=0, d=None, e=string requests模块以下实例展示了Python 解码 JSON 对象后检查key和操作字典：123456789101112#!/usr/bin/pythonimport jsonimport requestsdef json_request(): url = 'https://github.com/timeline.json' r = requests.get(url) data = r.json() for key, value in data.items(): print("%s=%s" % (key, value)) json_request() 以上代码执行结果为：12documentation_url=https://developer.github.com/v3/activity/events/#list-public-eventsmessage=Hello there, wayfaring stranger. If you’re reading this then you probably didn’t see our blog post a couple of years back announcing that this API would go away: http://git.io/17AROg Fear not, you should be able to get what you need from the shiny new Events API instead. 参考资料1.Python JSON教程2.python 读写 json文件3.运维那点事-Python模块：json4.Python JSON Documentation5.python-requests快速上手]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶-urllib2模块http请求]]></title>
    <url>%2F2018%2F03%2F19%2FPython%E8%BF%9B%E9%98%B6-urllib2%E6%A8%A1%E5%9D%97http%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[Python的http请求类最近工作基于urllib2模块实现一个httpHelper类，该类的使用方法：1.设置http header，URL，timeout，RetryTimes等；2.调用get，post，put，delete方法； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/usr/bin/env python# -*-coding:utf-8 -*-import loggingimport urllib2import time__metaclass = typeclass HttpHelper: def __init__(self): pass name = 'http helper' __reqHeader = &#123;&#125; __reqUrl = '' __reqTimeOut = 30 __reqRetryTimes = 5 __reqRetryIntervalTime = 5 def headers(self, headers): self.__reqHeader = headers return self def url(self, url): logging.debug("request url: %s" % url) self.__reqUrl = url return self def timeOut(self, time=30): self.__reqTimeOut = time return self def retryTime(self, times=3, interval_time=5): self.__reqRetryTimes = times self.__reqRetryIntervalTime = interval_time return self def debug(self): httpHandler = urllib2.HTTPHandler(debuglevel=1) httpsHandler = urllib2.HTTPSHandler(debuglevel=1) opener = urllib2.build_opener(httpHandler, httpsHandler) urllib2.install_opener(opener) return self def __buildGetRequest(self): if len(self.__reqHeader) == 0: request = urllib2.Request(self.__reqUrl) else: request = urllib2.Request(self.__reqUrl, headers=self.__reqHeader) return request def __buildPostPutDeleteRequest(self, postData): if len(self.__reqHeader) == 0: request = urllib2.Request(self.__reqUrl, data=postData) else: request = urllib2.Request(self.__reqUrl, headers=self.__reqHeader, data=postData) return request def __handleResponse(self, request, func): for _ in range(self.__reqRetryTimes): try: if self.__reqTimeOut == 0: res = urllib2.urlopen(request) else: res = urllib2.urlopen(request, timeout=self.__reqTimeOut) except urllib2.HTTPError, e: logging.error("urlopen HTTPError code:%s. url:%s" % (e.code, e.geturl())) time.sleep(self.__reqRetryIntervalTime) except urllib2.URLError, e: logging.error("urlopen URLError code:%s. reason:%s" % (e.code, e.reason)) time.sleep(self.__reqRetryIntervalTime) except Exception, e: logging.error("urlopen Exception Error:%s." % str(e)) time.sleep(self.__reqRetryIntervalTime) else: func(res.read()) break else: logging.error("urlopen over retry time %d error. url:%d." % (self.__reqRetryTimes, self.__reqUrl)) return False return True def get(self, func): request = self.__buildGetRequest() return self.__handleResponse(request, func) def post(self, postData, func): request = self.__buildPostPutDeleteRequest(postData=postData) return self.__handleResponse(request, func) def put(self, putData, func): request = self.__buildPostPutDeleteRequest(postData=putData) request.get_method = lambda: 'PUT' return self.__handleResponse(request, func) def delete(self, putData, func): request = self.__buildPostPutDeleteRequest(postData=putData) request.get_method = lambda: 'DELETE' return self.__handleResponse(request, func) Python的http请求类示例基于httpHelper类实现一个简单的get请求代码如下：12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env python# -*- coding:utf-8 -*-import loggingimport osfrom http_helper import HttpHelper def init_log(): log_file = os.path.join("/tmp/", 'http_help_%d.log' % os.getpid()) logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s', datefmt='%Y-%m-%d %H:%M:%S', filename=log_file, filemode='w')class HttpHelperTest(): def __init__(self): self.httpHelper = HttpHelper() self.httpHelper.debug() def __handlerResponse(self, data): logging.debug("response data: %s" % data) def httpGet(self): url = "https://www.baidu.com/" result = self.httpHelper.url(url).get(self.__handlerResponse)def main(): init_log() test = HttpHelperTest() test.httpGet()if __name__ == "__main__": main() 3.参考链接1.urllib2 document2.Retrying a web request in Python]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>urllib2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶-Pyinotify文件系统监控]]></title>
    <url>%2F2018%2F03%2F17%2FPython%E8%BF%9B%E9%98%B6-Pyinotify%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[Pyinotify介绍Pyinotify 是一个简单而有用的 Python 模块，它可用于在 Linux 中实时监控文件系统更改。它依赖于 inotify（在内核 2.6.13 中纳入的 Linux 内核功能），它是一个事件驱动的通知程序，其通知通过三个系统调用从内核空间导出到用户空间。Pyinotify 既可以监视文件，也可以监视目录。 Pyinotify示例最近在工作中有个需求：监控业务数据文件的创建事件。在网上查找用 pyinotify模块可以很容易的实时监控文件系统更改或修改。12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python#coding = utf-8import osfrom pyinotify import WatchManager, Notifier, ProcessEventfrom pyinotify import IN_DELETE, IN_CREATE, IN_MODIFYclass EventHandler(ProcessEvent): def process_IN_CREATE(self, event): event_file = os.path.join(event.path, event.name) print "create file: %s " % event_file def process_IN_DELETE(self, event): event_file = os.path.join(event.path, event.name) print "delete file: %s " % event_file def process_IN_MODIFY(self, event): event_file = os.path.join(event.path, event.name) print "modify file: %s " % event_file def FSMonitor(path='.'): wm = WatchManager() mask = IN_DELETE | IN_MODIFY | IN_CREATE notifier = Notifier(wm, EventHandler()) wm.add_watch(path, mask, rec=True, auto_add=True) print "now starting monitor %s." % path while True: try: notifier.process_events() if notifier.check_events(): notifier.read_events() except KeyboardInterrupt: notifier.stop() breakif __name__ == "__main__": FSMonitor()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>Pyinotify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ String删除所有的某个特定字符]]></title>
    <url>%2F2018%2F03%2F16%2FC-String%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1.remove和erase函数实现我们利用std::remove和boost::algorithm::erase函数实现从String中删除所有的某个特定字符，代码如下：s.erase(std::remove(s.begin(), s.end(), &#39;:&#39;), s.end());其中std::remove模板函数1234template&lt; class ForwardIt, class T &gt;ForwardIt remove( ForwardIt first, ForwardIt last, const T&amp; value );template&lt; class ForwardIt, class UnaryPredicate &gt;ForwardIt remove_if( ForwardIt first, ForwardIt last, UnaryPredicate p ); 从范围 [first, last) 移除所有满足特定判别标准的元素，并返回范围新结尾的尾后迭代器。1) 移除所有等于 value 的元素。2) 移除所有 p 对于它返回 true 的元素。 代码示例：123456789101112#include &lt;boost/algorithm/string.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace boost::algorithm;int main() &#123; std::string s = "08:EF:13:AB:88:BI"; s.erase(std::remove(s.begin(), s.end(), ':'), s.end()); std::cout &lt;&lt; s &lt;&lt; '\n';&#125; 运行结果：108EF13AB88BI 2.remove_erase函数实现boost库remove_erase函数源码是采用remove和erase方法实现。代码示例：12345678910#include &lt;boost/range/algorithm_ext.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string s = "08:EF:13:AB:88:BI"; boost::range::remove_erase(s, ':'); std::cout &lt;&lt; s &lt;&lt; '\n';&#125; 运行结果：108EF13AB88BI 3.参考链接1.C++从string中删除所有的某个特定字符2.std::remove, std::remove_if3.remove_erase documentation4.remove_erase source code]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ String字符串大小转换]]></title>
    <url>%2F2018%2F03%2F16%2FC-String%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[1.Boost.StringAlgorithms库大小转换函数大小写转换API：boost::algorithm::to_upper_copy()boost::algorithm::to_lower_copy()boost::algorithm::to_upper() //修改原string字符串boost::algorithm::to_lower() //修改原string字符串 代码示例：1234567891011#include &lt;boost/algorithm/string.hpp&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace boost::algorithm;int main()&#123; std::string s = "Boost C++ Libraries"; std::cout &lt;&lt; to_upper_copy(s) &lt;&lt; std::endl;&#125; 运行结果：1BOOST C++ LIBRARIES 2.STL库transform模板函数实现我们利用STL库提供transform模板函数，动作是toupper或tolower，完成std::string大(小)写转换的功能。 代码示例：123456789101112#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;int main() &#123; std::string s = "Boost C++ Libraries"; std::transform(s.begin(), s.end(), s.begin(), ::toupper); // std::transform(s.begin(), s.end(), s.begin(), ::tolower); std::cout &lt;&lt; s &lt;&lt; std::endl;&#125; 运行结果：1BOOST C++ LIBRARIES 3.参考链接1.Chapter 5. Boost.StringAlgorithms2.string转化大小写(C++)3.std::transform]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rapidjson库的json字符串读写]]></title>
    <url>%2F2018%2F03%2F12%2Frapidjson%E5%BA%93%E7%9A%84json%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[1.rapidjson简介rapidjson是腾讯的开源json解析框架，用c++实现。由于全部代码仅用header file实现，所以很容易集成到项目中。 RapidJSON GitHub RapidJSON 文档 ：English，简体中文，GitBook ，rapidjson代码剖析rapidjson安装123unzip rapidjson-1.1.0.zipcd rapidjson-1.1.0cp -a include/rapidjson /usr/include/ 2.json字符串读写最近在工作中使用rapidjson库实现json字符串操作，下面以读写json字符串为例进行整理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;rapidjson/document.h&gt;#include &lt;rapidjson/prettywriter.h&gt;#include &lt;rapidjson/stringbuffer.h&gt;#include &lt;rapidjson/writer.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;std::string JsonToString(const rapidjson::Value &amp;json) &#123; rapidjson::StringBuffer str_buf; rapidjson::PrettyWriter&lt;rapidjson::StringBuffer&gt; writer(str_buf); json.Accept(writer); return str_buf.GetString();&#125;bool JsonCheckField(const rapidjson::Value &amp;json, const char *field_key, bool (rapidjson::Value::*validator)() const, bool is_required) &#123; if (!json.HasMember(field_key)) &#123; if (is_required) &#123; std::cout &lt;&lt; "Invalid json: " &lt;&lt; JsonToString(json) &lt;&lt; " , miss key " &lt;&lt; field_key &lt;&lt; std::endl; &#125; return false; &#125; if (!(json[field_key].*validator)()) &#123; std::cout &lt;&lt; "Invalid json: " &lt;&lt; JsonToString(json) &lt;&lt; " , invalid key " &lt;&lt; field_key &lt;&lt; std::endl; return false; &#125; return true;&#125;bool JsonParse(const std::string &amp;data) &#123; rapidjson::Document doc; if (doc.Parse(data.c_str()).HasParseError()) &#123; std::cout &lt;&lt; "Failed to parse json string: " &lt;&lt; data &lt;&lt; ", error is: " &lt;&lt; doc.GetParseError() &lt;&lt; std::endl; return false; &#125; std::cout &lt;&lt; "JsonParse data:" &lt;&lt; std::endl; // Int64 if (JsonCheckField(doc, "Int64", &amp;rapidjson::Value::IsInt64, true)) &#123; std::cout &lt;&lt; "Int64 = " &lt;&lt; doc["Int64"].GetInt64() &lt;&lt; std::endl; &#125; // Object if (JsonCheckField(doc, "Object", &amp;rapidjson::Value::IsObject, true)) &#123; const rapidjson::Value &amp;object = doc["Object"]; if (JsonCheckField(object, "name", &amp;rapidjson::Value::IsString, true)) &#123; std::cout &lt;&lt; "Object.name = " &lt;&lt; object["name"].GetString() &lt;&lt; std::endl; &#125; if (JsonCheckField(object, "age", &amp;rapidjson::Value::IsInt, true)) &#123; std::cout &lt;&lt; "Object.age = " &lt;&lt; object["age"].GetInt() &lt;&lt; std::endl; &#125; &#125; // StringArray if (JsonCheckField(doc, "StringArray", &amp;rapidjson::Value::IsArray, true)) &#123; const rapidjson::Value &amp;array = doc["StringArray"]; size_t len = array.Size(); for (size_t i = 0; i &lt; len; i++) &#123; std::cout &lt;&lt; "StringArray[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; array[i].GetString() &lt;&lt; std::endl; &#125; &#125; // ObjectArray if (JsonCheckField(doc, "ObjectArray", &amp;rapidjson::Value::IsArray, true)) &#123; const rapidjson::Value &amp;array = doc["ObjectArray"]; size_t len = array.Size(); for (size_t i = 0; i &lt; len; i++) &#123; const rapidjson::Value &amp;object = array[i]; if (object.IsObject()) &#123; std::cout &lt;&lt; "ObjectArray[" &lt;&lt; i &lt;&lt; "]:"; if (JsonCheckField(object, "name", &amp;rapidjson::Value::IsString, true)) &#123; std::cout &lt;&lt; "name = " &lt;&lt; object["name"].GetString(); &#125; if (JsonCheckField(object, "age", &amp;rapidjson::Value::IsInt, true)) &#123; std::cout &lt;&lt; ", age = " &lt;&lt; object["age"].GetInt() &lt;&lt; std::endl; &#125; &#125; &#125; &#125; return true;&#125;void JsonSerialize(std::string *data) &#123; rapidjson::StringBuffer str_buf; rapidjson::Writer&lt;rapidjson::StringBuffer&gt; writer(str_buf); writer.StartObject(); // Int64 writer.Key("Int64"); writer.Int64(123456789); // Object writer.Key("Object"); writer.StartObject(); writer.Key("name"); writer.String("zhangsan"); writer.Key("age"); writer.Int(28); writer.EndObject(); // StringArray writer.Key("StringArray"); writer.StartArray(); writer.String("one"); writer.String("tow"); writer.String("three"); writer.EndArray(); // ObjectArray writer.Key("ObjectArray"); writer.StartArray(); for (int i = 0; i &lt; 3; i++) &#123; writer.StartObject(); writer.Key("name"); writer.String("wangwu"); writer.Key("age"); writer.Int(20 + i); writer.EndObject(); &#125; writer.EndArray(); writer.EndObject(); *data = str_buf.GetString(); std::cout &lt;&lt; "Json data: " &lt;&lt; *data &lt;&lt; std::endl;&#125;int main(int argc, char *argv[]) &#123; std::string data; JsonSerialize(&amp;data); JsonParse(data); return 0;&#125; 12345678910111213程序运行结果如下：JsonSerialize data: &#123;&quot;Int64&quot;:123456789,&quot;Object&quot;:&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:28&#125;,&quot;StringArray&quot;:[&quot;one&quot;,&quot;tow&quot;,&quot;three&quot;],&quot;ObjectArray&quot;:[&#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:20&#125;,&#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:21&#125;,&#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:22&#125;]&#125;JsonParse data:Int64 = 123456789Object.name = zhangsanObject.age = 28StringArray[0] = oneStringArray[1] = towStringArray[2] = threeObjectArray[0]:name = wangwu, age = 20ObjectArray[1]:name = wangwu, age = 21ObjectArray[2]:name = wangwu, age = 22 3.参考资料RapidJSON 文档-简体中文rapidjson库的基本使用]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Json</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++字符串分隔方法]]></title>
    <url>%2F2018%2F03%2F11%2FC-C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E9%9A%94%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.用strtok函数实现原型：char strtok(char str, const char *delim);功能：分解字符串为一组字符串。参数说明：str为要分解的字符串，delim为分隔符字符串。返回值：从str开头开始的一个个被分割的串。当没有被分割的串时则返回NULL。 示例代码和运行结果：123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char s[] = "aaa/bbb,ccc/ddd"; const char *d = ",/"; char *p; p = strtok(s, d); while (p) &#123; printf("%s\n", p); p = strtok(NULL, d); &#125; return 0;&#125; 12345运行结果aaabbbcccddd 2.用boost库的split函数实现boost库在头文件中提供了split函数处理字符串分隔。原型：template SequenceSequenceT &amp; split(SequenceSequenceT &amp; Result, RangeT &amp; Input, PredicateT Pred, token_compress_mode_type eCompress = token_compress_off);功能：以Pred为分隔符分隔Input字符串。参数说明：如果eCompress参数设置为token_compress_on，则相邻分隔符合并在一起。 否则，每两个分隔符分隔一个标记。str为要分解的字符串，delim为分隔符字符串。返回值：分割后的字符串存放在Result容器中。 示例代码和运行结果：1234567891011121314151617#include &lt;boost/algorithm/string/classification.hpp&gt; #include &lt;boost/algorithm/string/split.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main() &#123; string s = "aaa/bbb,ccc/ddd"; vector&lt;string&gt; vStr; boost::split(vStr, s, boost::is_any_of(",/"), boost::token_compress_on); for (vector&lt;string&gt;::iterator it = vStr.begin(); it != vStr.end(); ++it)&#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; return 0;&#125; 12345运行结果aaabbbcccddd]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶-计算程序运行时间]]></title>
    <url>%2F2018%2F03%2F11%2FPython%E8%BF%9B%E9%98%B6-%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[计算程序运行时间方法1Python的time模块包含很多与时间相关函数。我们可通过它获得当前的时间和格式化时间输出。123456789101112131415161718from time import timedef timeTest(): start = time() print("Start: " + str(start)) for i in range(1, 100000000): pass stop = time() print("Stop: " + str(stop)) print(str(round(stop-start, 2)) + "秒")def main(): timeTest()if __name__=='__main__': main() 计算程序运行时间方法2Python: 使用装饰器“@”取得函数执行时间]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶-Excel文件读写操作]]></title>
    <url>%2F2017%2F12%2F20%2FPython%E8%BF%9B%E9%98%B6-Excel%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Python第三方库Python读写Excel文件依赖第三方库：xlrd和xlwt。xlrd：可以读取.xls、.xlsx文件xlwt：可以写Excel文件，生成.xls格式后缀，但不可以直接修改Excel文件。下面使用pip安装xlrd和xlwt第三方库如下：12pip install xlrdpip install xlwt Python在线手册：http://www.python-excel.org/ Excel文件组织方式每一个Excel数据文件从上至下分为三个层级的对象：workbook： 每一个Excel文件就是一个workbook。sheet： 每一个workbook中可以包含多个sheet，具体就对应Excel中我们在左下脚所看到的“sheet1”,“sheet2”等。cell： 每一个sheet就是我们通常所看到的一个表格，可以含有m行，n列，每个确定的行号，列号所对应的一个格子就是一个cell。 Python Excel文件读操作 导入模块import xlrd 打开Excel文件book = xlrd.open_workbook(‘excelFile.xls’) Book类的方法、属性等：book.nsheets: 在Book对象中的文件有多少个worksheet。book.sheet_by_index(sheetx): 根据提供的sheetx索引来获取对应的sheet表，返回一个Sheet类的对象。book.sheet_by_name(sheet_name): 根据提供的sheet_name来获取对应的sheet表，返回一个Sheet类的对象。book.sheet_names(): 返回Book对象中的所有sheet表的名称列表。book.sheets(): 返回在Book对象中所有的Sheet对象实例列表。 获取Excel文件工作表sh = book.sheet_by_index(0) #通过索引顺序获取sh = book.sheet_by_name(u’Sheet1’)#通过名称获取 Sheet类方法、属性等：sh.cell(rowx, colx): 根据给出的行和列的参数获取得到cell类，返回一个Cell类实例对象sh.cell_type(rowx, colx): 返回对应的cell对象的Type类型sh.cell_value(rowx, colx): 返回对应的cell对象的value值sh.col_values(colx): 返回指定列的所有cell对象的value值sh.row_values(rowx): 返回指定的行的所有cell对象的value值sh.name: 返回sheet对象的名称sh.ncols: 返回在sheet对象中的列的数目sh.nrows: 返回在sheet对象中的行的数目book = xlrd.open_workbook(‘excelFile.xls’) 获取Excel文件工作表cell的值：cell=sh.cell(rowx=1, colx=1) #根据输入行和列获返回一个Cell类对象，cell.value获取值sh.cell_value(rowx=1, colx=1) ##根据输入行和列获返回一个Cell类对象的值 Python Excel文件写操作 导入模块import xlwt 打开Excel文件book = xlrd.Workbook(‘excelFile.xls’) 添加Excel文件工作表sheet1 = wb.add_sheet(‘heet_name’) 写Excel文件工作表cell的值：sheet1.write(0, 0, ‘test1’)row1 = sheet1.row(1)col1=sheet2.col(1)row1.write(0, ‘test2’)col1.write(1, ‘test3’) 保存Excel文件wb.save(‘excelFile.xls’) Python Excel文件读写操作示例Excel文件读写操作excel_handler.py示例：1.读取inputfile文件内容，并保存到row_contents列表中；2.将row_title和row_contents列表重新写到outputfile文件中；3.执行：python excel_handler.py personInfo.xlsx result.xls12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/env python# -*- coding:utf-8 -*-import datetimeimport osimport sysimport xlrdimport xlwtfrom time import timedef excel_file_read(filename): if not os.path.isfile(filename): print ("%s is not file." % filename) return None try: book = xlrd.open_workbook(filename) sh = book.sheet_by_index(0) except: print ("read %s open error." % filename) return None print("Sheet name:%s, nrows:%d, ncols:%d" % (sh.name, sh.nrows, sh.ncols)) row_contents = [] for rx in range(sh.nrows): row_content = [] for cx in range(sh.ncols): #print sh.cell_value(rx, cx) row_content.append(sh.cell_value(rx, cx)) row_contents.append(row_content) #print row_contents return row_contents[1:]def excel_file_write(filename, row_title, row_contents): try: wb = xlwt.Workbook() ws = wb.add_sheet("Sheet1") except: print ("write %s open error." % filename) return for col, col_content in enumerate(row_title): #print col, col_content ws.write(0, col, col_content) for row, row_content in enumerate(row_contents): for col, col_content in enumerate(row_content): #print col, col_content ws.write(row + 1, col, col_content) wb.save(filename)def get_opt_init(argv): if len(argv) &lt; 3: print "python excel_handler.py inputfile outputfile" return None if len(argv) &gt;= 3: inputfile = argv[1] outputfile = argv[2] return inputfile, outputfile if __name__=="__main__" : start = time() inputfile, outputfile = get_opt_init(sys.argv) if not inputfile and outputfile: sys.exit(0) row_contents = excel_file_read(inputfile) if not row_contents: sys.exit(0) row_title = [u'姓名', u'年龄', u'电话'] excel_file_write(outputfile, row_title, row_contents) print "Time cost %.2fs." % (time() - start) 遇到问题问题现象：执行脚本，在save方法报编码错误12345File "excel_handler.py", line 55, in excel_file_write wb.save(filename).......File "/usr/local/lib/python2.7/site-packages/xlwt/UnicodeUtils.py", line 50, in upack2 us = unicode(s, encoding) 解决方法：row_title = [‘姓名’, ‘年龄’, ‘电话’]修改成row_title = [u’姓名’, u’年龄’, u’电话’] 参考链接：http://blog.sina.com.cn/s/blog_6babbcb8010182c3.htmlhttp://blog.csdn.net/wangkai_123456/article/details/50457284]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶-csv文件读写]]></title>
    <url>%2F2017%2F12%2F20%2FPython%E8%BF%9B%E9%98%B6-csv%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[Python csv模块Python的cvs模块可以实现csv文件读写操作，只需要在脚本中import csv模块。Python的cvs模块在线手册：https://docs.python.org/2/library/csv.html Python读csv文件12345678import csvcsvfile = file(filename, 'rb')reader = csv.reader(csvfile)for line in reader: print line csvfile.close() 获取csv文件行数：lines = sum(1 for line in reader) Python写csv文件123456789101112131415import csvcsvfile = file(filename, 'wb')writer = csv.writer(csvfile)'''写一行'''writer.writerow(['姓名', '年龄', '电话'])data = [ ('张三', '20', '18645674567'), ('李四', '22', '13511224567'), ('王五', '24', '18833444567')]'''写多行'''writer.writerows(data)csvfile.close() Python读写csv文件示例读写csv文件 cvs_handler.py示例：1.读取inputfile文件内容，并保存到row_contents列表中；2.将row_title和row_contents列表重新写到outputfile文件中；3.执行：python cvs_handler.py personInfo.csv result.csv1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/env python # -*- coding:utf-8 -*-import osimport csvimport sysfrom time import timedef cvs_file_read(filename): if not os.path.isfile(filename): print ("%s is not file." % filename) return None try: csvfile = file(filename, 'rb') reader = csv.reader(csvfile) except: print ("read %s open error." % filename) return None headers = next(reader) row_contents = [] for i, line in enumerate(reader): print i, line row_contents.append(line) csvfile.close() return row_contentsdef csv_file_write(filename, row_title, row_contents): try: csvfile = file(filename, 'wb') writer = csv.writer(csvfile) except: print ("write %s open error." % filename) return writer.writerow(row_title) writer.writerows(row_contents) csvfile.close()def get_opt_init(argv): if len(argv) &lt; 3: print "python cvs_handler.py inputfile outputfile" return None if len(argv) &gt;= 3: inputfile = argv[1] outputfile = argv[2] return inputfile, outputfile if __name__=="__main__" : start = time() inputfile, outputfile = get_opt_init(sys.argv) if not inputfile and outputfile: sys.exit(0) row_contents = cvs_file_read(inputfile) if not row_contents: sys.exit(0) row_title = ["姓名", "年龄", "电话"] csv_file_write(outputfile, row_title, row_contents) print "Time cost %.2fs." % (time() - start) personInfo.csv文件内容如下所示：12345[root@10.127.20.32 cvs]# cat personInfo.csv 姓名,年龄,电话张三,20,18645674567李四,22,13511224567王五,24,18833444567]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础-枚举类]]></title>
    <url>%2F2017%2F12%2F19%2FPython%E5%9F%BA%E7%A1%80-%E6%9E%9A%E4%B8%BE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Python基础枚举类有两种实现方法第一种方法：定义常量，变量名称大写，例如月份：123456JAN = 1FEB = 2MAR = 3...NOV = 11DEC = 12 第二种方法：从Enum派生出自定义枚举类，unique装饰器可以帮助我们检查保证没有重复值，例如星期：1234567891011from enum import Enum, unique @uniqueclass Weekday(Enum): Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 访问枚举类型的若干方法如下，可见在实际使用中既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。123456789101112131415161718192021&gt;&gt;&gt; print (Weekday.Mon)Weekday.Mon&gt;&gt;&gt; print (Weekday['Tue'])Weekday.Tue&gt;&gt;&gt; type(Weekday.Mon)&lt;enum 'Weekday'&gt;&gt;&gt;&gt; print(Weekday.Mon.value)1&gt;&gt;&gt; print(Weekday(1))Weekday.Mon&gt;&gt;&gt; for name, member in Weekday.__members__.items():... print(name, '=&gt;', member)... ('Sun', '=&gt;', &lt;Weekday.Sun: 0&gt;)('Mon', '=&gt;', &lt;Weekday.Mon: 1&gt;)('Tue', '=&gt;', &lt;Weekday.Tue: 2&gt;)('Wed', '=&gt;', &lt;Weekday.Wed: 3&gt;)('Thu', '=&gt;', &lt;Weekday.Thu: 4&gt;)('Fri', '=&gt;', &lt;Weekday.Fri: 5&gt;)('Sat', '=&gt;', &lt;Weekday.Sat: 6&gt;)&gt;&gt;&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础-rpm和yum常用命令]]></title>
    <url>%2F2017%2F10%2F06%2FLinux%E5%9F%BA%E7%A1%80-rpm%E5%92%8Cyum%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[rpm常用命令安装一个rpm包rpm -ivh file.rpm 参数说明：-i ：安装的意思-v ：可视化-h ：显示安装进度另外在安装一个rpm包时常用的附带参数有：–force 强制安装，即使覆盖属于其他包的文件也要安装–nodeps 当要安装的rpm包依赖其他包时，即使其他包没有安装，也要安装这个包 查看包依赖关系rpm -qpR file.rpm 卸载一个rpm包rpm -e file.rpm 查找是否已经安装了某个包rpm -qa | grep htop 查看安装的软件包安装了哪些文件rpm -ql htop 想知道本地文件来自那个软件包rpm -qf /usr/bin/htop rpm包下载网址： https://pkgs.org/ http://rpm.pbone.net https://rpmfind.net/ 参考链接：http://achuan.blog.51cto.com/102/60869 yum常用命令从 repo 中查找某个软件包yum search htop 查看yum安装源中包的版本信息yum info htop 从 repo 中查找哪个包提供了哪个文件yum provides /usr/bin/htop 安装软件包的最新或指定版本yum install [-y] htopyum install [-y] htop-2.0.1-1.el7 查看软件包所有可用的版本yum –showduplicate list htop 卸载软件包yum remove [-y] htop 升级软件包yum update [-y] htop 降级软件包到指定版本（软件包的新版本已经安装）yum downgrade htop-2.0.0-2.el7 删除 yum cacheyum clean all]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++时间结构体与获取函数]]></title>
    <url>%2F2017%2F10%2F06%2FC-C-%E6%97%B6%E9%97%B4%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[时间结构体C/C++中常用的时间结构体有三种：time_t、struct tm、struct timeval。 time_t时间值time_t时间值在time.h中定义如下：1234#ifndef __TIME_T #define __TIME_T typedef long time_t; #endif time_t是一个long型，表示从UTC时间(1970年1月1日00时00分00秒)到当前系统时刻的秒数。使用time()函数可以获取当前系统时间time_t的值。 struct tm时间结构体由于time_t以秒为单位表示可读性差，所以需要一个可以表示当前系统时间（年、月、日、时、分、秒）方式的数据结构struct tm。struct tm结构体也在time.h中定义如下：123456789101112struct tm &#123; int tm_sec; /* 秒,取值范围(0~59)，但当遇到闰秒时则会有60秒的取值。 */ int tm_min; /* 分钟数，取值范围(0-59) */ int tm_hour; /* 小时数，取值范围(0-23) */ int tm_mday; /* 当天在这个月中是第几天，取值范围(1-31) */ int tm_mon; /* 当前月份是第几个月，取值范围(0-11) */ int tm_year; /* 从1900年开始至今的年数，即(Year - 1900)的值 */ int tm_wday; /* 当天在本周是第几天，取值范围(0-6, Sunday = 0) */ int tm_yday; /* 当天在今年是第几天，取值范围(0-365, 1 Jan = 0) */ int tm_isdst; /* 夏令时标记，值大于0表示夏令时生效；等于0表示夏令时失效；小于0表示数据不可用。 */ char *tm_zone; /* 时区名称，根据系统不同可能不被声明或不同全名。 */&#125;; 使用localtime()和gmtime()函数可以把time_t时间值转换成struct tm。 struct timeval结构体由于time_t只能表示秒级时间粒度，而struct timeval结构体可以表示微秒级，其中tv_sec表示当前系统时刻的秒数，tv_usec表示当前系统时刻的微秒数，1秒 = 1000000微秒。struct timeval结构体在time.h中定义如下：1234567/* A time value that is accurate to the nearest microsecond but also has a range of years. */struct timeval&#123; __time_t tv_sec; /* Seconds. */ __suseconds_t tv_usec; /* Microseconds. */&#125;; 使用gettimeofday()函数获取当前系统时间struct timeval结构体的值。 时间获取函数主要介绍四个常用的时间获取函数：time()、gmtime()、localtime()、gettimeofday()。 time()函数头文件：#include &lt;time.h&gt;函数定义：time_t time (time_t *t)功能描述：该函数返回从UTC时间(1970年1月1日00时00分00秒)到当前系统所经过的秒数。返回值：成功则返回秒数，失败则返回((time_t)-1)值，错误原因存于errno中。 gmtime()函数头文件：#include &lt;time.h&gt;函数定义：struct tm *gmtime(time_t const *timep)功能描述：该函数将参数timep指向的time_t时间值转换成以tm结构体表示的世界标准时间UTC。返回值：返回结构体tm代表目前UTC 时间。 localtime()函数头文件：#include &lt;time.h&gt;函数定义：struct tm *localtime(time_t const *timep)功能描述：该函数将参数timep指向的time_t时间值转换成以tm结构体表示的本地时间（如北京时间）。返回值：返回结构体tm代表目前UTC 时间。 说明：以北京时间为例，gmtime()得到的结果比localtime()要提前(早)8小时。 gettimeofday()函数头文件：#include &lt;time.h&gt;函数定义：int gettimeofday (struct timeval *__restrict __tv, __timezone_ptr_t __tz)功能描述：该函数把当前的时间信息存入tv指向的结构体中，把当前时区信息存入tz指向的结构体中，如果tz为NULL则不向tz写入。返回值：成功则返回0，失败则返回-1值，错误原因存于errno中。 时间格式化字符串时间格式化字符串三个常用的函数有： ctime()、asctime()、strftime()、strptime()。 ctime()函数头文件：#include &lt;time.h&gt;函数定义：char *ctime(const time_t *timep)功能描述：将参数timep时间值转换成实际使用的时间日期表示方法。返回值：以字符串形式返回。字符串格式为：”Wed Jun 20 21:00:00 2012\n”。 asctime()函数头文件：#include &lt;time.h&gt;函数定义：char *asctime(const struct tm *tm)功能描述：将参数tm结构体转换成实际使用的时间日期表示方法。返回值：以字符串形式返回。字符串格式为：”Wed Jun 20 21:00:00 2012\n”。 说明：ctime()和asctime()的区别是函数的入参不同，返回的字符串格式化相同。 strftime()函数头文件：#include &lt;time.h&gt;函数定义：size_t strftime(char *s, size_t max, const char *format, const struct tm *tm)功能描述：格式化时间字符串，可以根据format指向字符串中格式命令把tm中保存的时间信息放在s指向的字符串中，最多向s中存放max个字符。返回值：向s指向的字符串中放置的字符数。 strftime()函数的操作有些类似于sprintf()：识别以百分号(%)开始的格式命令集合，格式化输出结果放在一个字符串中。下面仅挑几个常用的来说： 格式化参数 含义 %Y 完整的年数字 %m 月份，如月份是1~9,则数字前填充一个’0’ %d 日子 %F 等同于“%Y-%m-%d” %H 小时数 %M 分钟数 %S 秒数 %_m 月份，如果月份是1~9，则数字前有一个空格填充 %-m 月份，如果月份是1~9，仍只显示该数字 strptime()函数头文件：#include &lt;time.h&gt;函数定义：char *strptime(const char *s, const char *format, struct tm *tm)功能描述：将一个字符串格式化为一个tm结构，功能与strftime相反，根据format指向字符串中格式命令把s指向的字符串转换存储到tm中。返回值：指向转换过程处理的最后一个字符后面的那个字符。 时间代码示例运用上述介绍的结构体和函数编写的C语言代码如下：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;sys/time.h&gt;int main(int argc, char *argv[])&#123; time_t calendar_time; struct tm *tm_local; struct timeval start,end; long dif_sec, dif_usec, j; time(&amp;calendar_time); //calendar_time = time(NULL); printf("calendar_time: %ld\n", calendar_time); tm_local = localtime(&amp;calendar_time); printf("\nlocaltime :year=%d mon=%d mday=%d hour=%d min=%d sec=%d\n",tm_local-&gt;tm_year + 1900, tm_local-&gt;tm_mon + 1, tm_local-&gt;tm_mday, tm_local-&gt;tm_hour, tm_local-&gt;tm_min, tm_local-&gt;tm_sec); printf("asctime: %s\n", asctime(tm_local)); printf("ctime: %s\n", ctime(&amp;calendar_time)); char strtime[128]; strftime(strtime, sizeof(strtime), "%Y-%m-%d %H-%M-%S", tm_local); printf("localtime format: %s\n", strtime); //下面代码可以计算程序部分代码执行的时间(微秒) gettimeofday(&amp;start, NULL); for(int i = 0; i &lt; 10000000; ++i) j = 3.14 * i + 6.28 * i + 0.001 * i; gettimeofday(&amp;end, NULL); dif_sec = end.tv_sec - start.tv_sec; dif_usec = end.tv_usec - start.tv_usec; printf("running time is %ld sec (%ld usec)\n", dif_sec, dif_sec*1000000 + dif_usec); return 0;&#125; 程序运行结果如下：12345678910calendar_time: 1482079700localtime :year=2016 mon=12 mday=18 hour=8 min=48 sec=20asctime: Sun Dec 18 08:48:20 2016ctime: Sun Dec 18 08:48:20 2016localtime format: 2016-12-18 08-48-20running time is 0 sec (97651 usec) 运用strftime和strptime函数编写的C语言代码如下：1234567891011121314151617#include "stdio.h" int main(void) &#123; time_t lt = time(NULL); struct tm* ptr = localtime(&amp;lt); char szBuffer[64] = &#123;0&#125;; const char* pFormat = "The time now is %Y-%m-%d %H:%M:%S"; strftime(szBuffer, 64, pFormat, ptr); printf("%s\n", szBuffer); struct tm tmTemp; char tmBuffer[64] = &#123;0&#125;; strptime(szBuffer, pFormat, &amp;tmTemp);//字符串转换成struct tm结构体 strftime(tmBuffer, 64, "The time just was %Y-%m-%d %H:%M:%S", &amp;tmTemp); printf("%s\n", tmBuffer); return 0; &#125; 程序运行结果如下：12The time now is 2016-12-19 10:39:24The time just was 2016-12-19 10:39:24 获取当前时间戳和字符串形式时间转换时间戳代码如下：12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;time.h&gt;time_t get_timestamp(const char *date = NULL, const char *format = "%Y-%m-%d %H:%M:%S") &#123; struct tm tm = &#123;0&#125;; if (!date) &#123; return time(NULL); // return absl::ToUnixMillis(absl::Now()); // 毫秒 // return absl::ToTimeT(absl::Now()); // 秒 &#125; strptime(date, format, &amp;tm); return mktime(&amp;tm);&#125;int main(void) &#123; char date[] = "2018-02-10 19:00:00"; time_t now = get_timestamp(date); std::cout &lt;&lt; "date " &lt;&lt; date &lt;&lt; " to timestamp " &lt;&lt; now &lt;&lt; std::endl; now = get_timestamp(); std::cout &lt;&lt; "now timestamp " &lt;&lt; now &lt;&lt; std::endl; return 0;&#125; 程序运行结果如下：12date 2018-02-10 19:00:00 to timestamp 1518260400now timestamp 1521676868 ###参考链接： http://sodino.com/2015/03/15/c-time/ http://blog.csdn.net/yasaken/article/details/7429506 Unix时间戳http://tool.chinaz.com/Tools/unixtime.aspx]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>Linux系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础-VIM安装教程]]></title>
    <url>%2F2017%2F10%2F06%2FLinux%E5%9F%BA%E7%A1%80-VIM%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[yum安装Vim1.先卸载老的vim1yum remove vim-* -y 2.下载第三方yum源1wget -P /etc/yum.repos.d/ https://copr.fedorainfracloud.org/coprs/mcepl/vim8/repo/epel-7/mcepl-vim8-epel-7.repo 3.安装vim1yum -y install vim-enhanced sudo 4.验证vim版本12345rpm -qa |grep vimvim-enhanced-8.0.0704-1.1.26.el7.centos.x86_64vim-common-8.0.0704-1.1.26.el7.centos.x86_64vim-minimal-8.0.0704-1.1.26.el7.centos.x86_64vim-filesystem-8.0.0704-1.1.26.el7.centos.x86_64 安装过程遇到的依赖问题“libc.so.6 is needed by XXX”解决方法参考：http://www.cnblogs.com/think3t/p/4165102.html rpm包安装Vim1.Vim安装需要的四个rpm包如下：1234vim-filesystem-7.4.629-5.el6_8.1.x86_64.rpmvim-common-7.4.629-5.el6_8.1.x86_64.rpmvim-enhanced-7.4.629-5.el6_8.1.x86_64.rpm vim-minimal-7.4.629-5.el6_8.1.x86_64.rpm 2.登录rpmfind网站，下载vim的rpm包，注：centos只有7.4版本vim包 vim有四个包，下面是按照顺序 3.使用rpm命令安装Vim包，按照1中的顺序依次安装。1rpm -ivh 包名 4.查看vim版本号1vim --version | head 源码安装Vim1.安装依赖1yum -y install ruby perl-devel python-devel ruby-devel perl-ExtUtils-Embed ncurses-devel 2.源码下载源码下载方法一：克隆源码12git clone https://github.com/vim/vim.gitcd vim/ 源码下载方法二：下载压缩包1234wget https://github.com/vim/vim/archive/master.zipunzip master.zipcd vim-mastercd src/ 3.源码编译1234./configure --prefix=/usr/local --enable-multibyte --with-tlib=tinfo --enable-pythoninterp --enable-rubyinterp \--with-ruby-command=/usr/bin/ruby --with-features=hugemakemake install 4.查看vim版本号1vim --version | head]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
</search>
