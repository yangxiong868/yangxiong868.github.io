<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[rapidjson库的json字符串读写]]></title>
    <url>%2F2018%2F03%2F12%2Frapidjson%E5%BA%93%E7%9A%84json%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[1.rapidjson简介rapidjson是腾讯的开源json解析框架，用c++实现。由于全部代码仅用header file实现，所以很容易集成到项目中。 RapidJSON GitHub RapidJSON 文档 ：English，简体中文，GitBook ，rapidjson代码剖析 rapidjson安装123unzip rapidjson-1.1.0.zipcd rapidjson-1.1.0cp -a include/rapidjson /usr/include/ 2.json字符串读写最近在工作中使用rapidjson库实现json字符串操作，下面以读写json字符串为例进行整理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;rapidjson/document.h&gt;#include &lt;rapidjson/prettywriter.h&gt;#include &lt;rapidjson/stringbuffer.h&gt;#include &lt;rapidjson/writer.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;std::string JsonToString(const rapidjson::Value &amp;json) &#123; rapidjson::StringBuffer str_buf; rapidjson::PrettyWriter&lt;rapidjson::StringBuffer&gt; writer(str_buf); json.Accept(writer); return str_buf.GetString();&#125;bool JsonCheckField(const rapidjson::Value &amp;json, const char *field_key, bool (rapidjson::Value::*validator)() const, bool is_required) &#123; if (!json.HasMember(field_key)) &#123; if (is_required) &#123; std::cout &lt;&lt; "Invalid json: " &lt;&lt; JsonToString(json) &lt;&lt; " , miss key " &lt;&lt; field_key &lt;&lt; std::endl; &#125; return false; &#125; if (!(json[field_key].*validator)()) &#123; std::cout &lt;&lt; "Invalid json: " &lt;&lt; JsonToString(json) &lt;&lt; " , invalid key " &lt;&lt; field_key &lt;&lt; std::endl; return false; &#125; return true;&#125;bool JsonParse(const std::string &amp;data) &#123; rapidjson::Document doc; if (doc.Parse(data.c_str()).HasParseError()) &#123; std::cout &lt;&lt; "Failed to parse json string: " &lt;&lt; data &lt;&lt; ", error is: " &lt;&lt; doc.GetParseError() &lt;&lt; std::endl; return false; &#125; std::cout &lt;&lt; "JsonParse data:" &lt;&lt; std::endl; // Int64 if (JsonCheckField(doc, "Int64", &amp;rapidjson::Value::IsInt64, true)) &#123; std::cout &lt;&lt; "Int64 = " &lt;&lt; doc["Int64"].GetInt64() &lt;&lt; std::endl; &#125; // Object if (JsonCheckField(doc, "Object", &amp;rapidjson::Value::IsObject, true)) &#123; const rapidjson::Value &amp;object = doc["Object"]; if (JsonCheckField(object, "name", &amp;rapidjson::Value::IsString, true)) &#123; std::cout &lt;&lt; "Object.name = " &lt;&lt; object["name"].GetString() &lt;&lt; std::endl; &#125; if (JsonCheckField(object, "age", &amp;rapidjson::Value::IsInt, true)) &#123; std::cout &lt;&lt; "Object.age = " &lt;&lt; object["age"].GetInt() &lt;&lt; std::endl; &#125; &#125; // StringArray if (JsonCheckField(doc, "StringArray", &amp;rapidjson::Value::IsArray, true)) &#123; const rapidjson::Value &amp;array = doc["StringArray"]; size_t len = array.Size(); for (size_t i = 0; i &lt; len; i++) &#123; std::cout &lt;&lt; "StringArray[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; array[i].GetString() &lt;&lt; std::endl; &#125; &#125; // ObjectArray if (JsonCheckField(doc, "ObjectArray", &amp;rapidjson::Value::IsArray, true)) &#123; const rapidjson::Value &amp;array = doc["ObjectArray"]; size_t len = array.Size(); for (size_t i = 0; i &lt; len; i++) &#123; const rapidjson::Value &amp;object = array[i]; if (object.IsObject()) &#123; std::cout &lt;&lt; "ObjectArray[" &lt;&lt; i &lt;&lt; "]:"; if (JsonCheckField(object, "name", &amp;rapidjson::Value::IsString, true)) &#123; std::cout &lt;&lt; "name = " &lt;&lt; object["name"].GetString(); &#125; if (JsonCheckField(object, "age", &amp;rapidjson::Value::IsInt, true)) &#123; std::cout &lt;&lt; ", age = " &lt;&lt; object["age"].GetInt() &lt;&lt; std::endl; &#125; &#125; &#125; &#125; return true;&#125;void JsonSerialize(std::string *data) &#123; rapidjson::StringBuffer str_buf; rapidjson::Writer&lt;rapidjson::StringBuffer&gt; writer(str_buf); writer.StartObject(); // Int64 writer.Key("Int64"); writer.Int64(123456789); // Object writer.Key("Object"); writer.StartObject(); writer.Key("name"); writer.String("zhangsan"); writer.Key("age"); writer.Int(28); writer.EndObject(); // StringArray writer.Key("StringArray"); writer.StartArray(); writer.String("one"); writer.String("tow"); writer.String("three"); writer.EndArray(); // ObjectArray writer.Key("ObjectArray"); writer.StartArray(); for (int i = 0; i &lt; 3; i++) &#123; writer.StartObject(); writer.Key("name"); writer.String("wangwu"); writer.Key("age"); writer.Int(20 + i); writer.EndObject(); &#125; writer.EndArray(); writer.EndObject(); *data = str_buf.GetString(); std::cout &lt;&lt; "Json data: " &lt;&lt; *data &lt;&lt; std::endl;&#125;int main(int argc, char *argv[]) &#123; std::string data; JsonSerialize(&amp;data); JsonParse(data); return 0;&#125; 12345678910111213程序运行结果如下：JsonSerialize data: &#123;&quot;Int64&quot;:123456789,&quot;Object&quot;:&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:28&#125;,&quot;StringArray&quot;:[&quot;one&quot;,&quot;tow&quot;,&quot;three&quot;],&quot;ObjectArray&quot;:[&#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:20&#125;,&#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:21&#125;,&#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:22&#125;]&#125;JsonParse data:Int64 = 123456789Object.name = zhangsanObject.age = 28StringArray[0] = oneStringArray[1] = towStringArray[2] = threeObjectArray[0]:name = wangwu, age = 20ObjectArray[1]:name = wangwu, age = 21ObjectArray[2]:name = wangwu, age = 22 3.参考资料RapidJSON 文档-简体中文rapidjson库的基本使用]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++字符串分隔方法]]></title>
    <url>%2F2018%2F03%2F11%2FC-C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E9%9A%94%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.用strtok函数实现原型：char strtok(char str, const char *delim);功能：分解字符串为一组字符串。参数说明：str为要分解的字符串，delim为分隔符字符串。返回值：从str开头开始的一个个被分割的串。当没有被分割的串时则返回NULL。 示例代码和运行结果：123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char s[] = "aaa/bbb,ccc/ddd"; const char *d = ",/"; char *p; p = strtok(s, d); while (p) &#123; printf("%s\n", p); p = strtok(NULL, d); &#125; return 0;&#125; 12345运行结果aaabbbcccddd 2.用boost库的split函数实现boost库在头文件中提供了split函数处理字符串分隔。原型：template SequenceSequenceT &amp; split(SequenceSequenceT &amp; Result, RangeT &amp; Input, PredicateT Pred, token_compress_mode_type eCompress = token_compress_off);功能：以Pred为分隔符分隔Input字符串。参数说明：如果eCompress参数设置为token_compress_on，则相邻分隔符合并在一起。 否则，每两个分隔符分隔一个标记。str为要分解的字符串，delim为分隔符字符串。返回值：分割后的字符串存放在Result容器中。 示例代码和运行结果：1234567891011121314151617#include &lt;boost/algorithm/string/classification.hpp&gt; #include &lt;boost/algorithm/string/split.hpp&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main() &#123; string s = "aaa/bbb,ccc/ddd"; vector&lt;string&gt; vStr; boost::split(vStr, s, boost::is_any_of(",/"), boost::token_compress_on); for (vector&lt;string&gt;::iterator it = vStr.begin(); it != vStr.end(); ++it)&#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; return 0;&#125; 12345运行结果aaabbbcccddd]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶-计算程序运行时间]]></title>
    <url>%2F2018%2F03%2F11%2FPython%E8%BF%9B%E9%98%B6-%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[计算程序运行时间方法1Python的time模块包含很多与时间相关函数。我们可通过它获得当前的时间和格式化时间输出。123456789101112131415161718from time import timedef timeTest(): start = time() print("Start: " + str(start)) for i in range(1, 100000000): pass stop = time() print("Stop: " + str(stop)) print(str(round(stop-start, 2)) + "秒")def main(): timeTest()if __name__=='__main__': main() 计算程序运行时间方法2Python: 使用装饰器“@”取得函数执行时间]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶-Excel文件读写操作]]></title>
    <url>%2F2017%2F12%2F20%2FPython%E8%BF%9B%E9%98%B6-Excel%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Python第三方库Python读写Excel文件依赖第三方库：xlrd和xlwt。xlrd：可以读取.xls、.xlsx文件xlwt：可以写Excel文件，生成.xls格式后缀，但不可以直接修改Excel文件。下面使用pip安装xlrd和xlwt第三方库如下：12pip install xlrdpip install xlwt Python在线手册：http://www.python-excel.org/ Excel文件组织方式每一个Excel数据文件从上至下分为三个层级的对象：workbook： 每一个Excel文件就是一个workbook。sheet： 每一个workbook中可以包含多个sheet，具体就对应Excel中我们在左下脚所看到的“sheet1”,“sheet2”等。cell： 每一个sheet就是我们通常所看到的一个表格，可以含有m行，n列，每个确定的行号，列号所对应的一个格子就是一个cell。 Python Excel文件读操作 导入模块import xlrd 打开Excel文件book = xlrd.open_workbook(‘excelFile.xls’) Book类的方法、属性等：book.nsheets: 在Book对象中的文件有多少个worksheet。book.sheet_by_index(sheetx): 根据提供的sheetx索引来获取对应的sheet表，返回一个Sheet类的对象。book.sheet_by_name(sheet_name): 根据提供的sheet_name来获取对应的sheet表，返回一个Sheet类的对象。book.sheet_names(): 返回Book对象中的所有sheet表的名称列表。book.sheets(): 返回在Book对象中所有的Sheet对象实例列表。 获取Excel文件工作表sh = book.sheet_by_index(0) #通过索引顺序获取sh = book.sheet_by_name(u’Sheet1’)#通过名称获取 Sheet类方法、属性等：sh.cell(rowx, colx): 根据给出的行和列的参数获取得到cell类，返回一个Cell类实例对象sh.cell_type(rowx, colx): 返回对应的cell对象的Type类型sh.cell_value(rowx, colx): 返回对应的cell对象的value值sh.col_values(colx): 返回指定列的所有cell对象的value值sh.row_values(rowx): 返回指定的行的所有cell对象的value值sh.name: 返回sheet对象的名称sh.ncols: 返回在sheet对象中的列的数目sh.nrows: 返回在sheet对象中的行的数目book = xlrd.open_workbook(‘excelFile.xls’) 获取Excel文件工作表cell的值：cell=sh.cell(rowx=1, colx=1) #根据输入行和列获返回一个Cell类对象，cell.value获取值sh.cell_value(rowx=1, colx=1) ##根据输入行和列获返回一个Cell类对象的值 Python Excel文件写操作 导入模块import xlwt 打开Excel文件book = xlrd.Workbook(‘excelFile.xls’) 添加Excel文件工作表sheet1 = wb.add_sheet(‘heet_name’) 写Excel文件工作表cell的值：sheet1.write(0, 0, ‘test1’)row1 = sheet1.row(1)col1=sheet2.col(1)row1.write(0, ‘test2’)col1.write(1, ‘test3’) 保存Excel文件wb.save(‘excelFile.xls’) Python Excel文件读写操作示例Excel文件读写操作excel_handler.py示例：1.读取inputfile文件内容，并保存到row_contents列表中；2.将row_title和row_contents列表重新写到outputfile文件中；3.执行：python excel_handler.py personInfo.xlsx result.xls12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/env python# -*- coding:utf-8 -*-import datetimeimport osimport sysimport xlrdimport xlwtfrom time import timedef excel_file_read(filename): if not os.path.isfile(filename): print ("%s is not file." % filename) return None try: book = xlrd.open_workbook(filename) sh = book.sheet_by_index(0) except: print ("read %s open error." % filename) return None print("Sheet name:%s, nrows:%d, ncols:%d" % (sh.name, sh.nrows, sh.ncols)) row_contents = [] for rx in range(sh.nrows): row_content = [] for cx in range(sh.ncols): #print sh.cell_value(rx, cx) row_content.append(sh.cell_value(rx, cx)) row_contents.append(row_content) #print row_contents return row_contents[1:]def excel_file_write(filename, row_title, row_contents): try: wb = xlwt.Workbook() ws = wb.add_sheet("Sheet1") except: print ("write %s open error." % filename) return for col, col_content in enumerate(row_title): #print col, col_content ws.write(0, col, col_content) for row, row_content in enumerate(row_contents): for col, col_content in enumerate(row_content): #print col, col_content ws.write(row + 1, col, col_content) wb.save(filename)def get_opt_init(argv): if len(argv) &lt; 3: print "python excel_handler.py inputfile outputfile" return None if len(argv) &gt;= 3: inputfile = argv[1] outputfile = argv[2] return inputfile, outputfile if __name__=="__main__" : start = time() inputfile, outputfile = get_opt_init(sys.argv) if not inputfile and outputfile: sys.exit(0) row_contents = excel_file_read(inputfile) if not row_contents: sys.exit(0) row_title = [u'姓名', u'年龄', u'电话'] excel_file_write(outputfile, row_title, row_contents) print "Time cost %.2fs." % (time() - start) 遇到问题问题现象：执行脚本，在save方法报编码错误12345File "excel_handler.py", line 55, in excel_file_write wb.save(filename).......File "/usr/local/lib/python2.7/site-packages/xlwt/UnicodeUtils.py", line 50, in upack2 us = unicode(s, encoding) 解决方法：row_title = [‘姓名’, ‘年龄’, ‘电话’]修改成row_title = [u’姓名’, u’年龄’, u’电话’] 参考链接：http://blog.sina.com.cn/s/blog_6babbcb8010182c3.htmlhttp://blog.csdn.net/wangkai_123456/article/details/50457284]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶-csv文件读写]]></title>
    <url>%2F2017%2F12%2F20%2FPython%E8%BF%9B%E9%98%B6-csv%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[Python csv模块Python的cvs模块可以实现csv文件读写操作，只需要在脚本中import csv模块。Python的cvs模块在线手册：https://docs.python.org/2/library/csv.html Python读csv文件12345678import csvcsvfile = file(filename, 'rb')reader = csv.reader(csvfile)for line in reader: print line csvfile.close() 获取csv文件行数：lines = sum(1 for line in reader) Python写csv文件123456789101112131415import csvcsvfile = file(filename, 'wb')writer = csv.writer(csvfile)'''写一行'''writer.writerow(['姓名', '年龄', '电话'])data = [ ('张三', '20', '18645674567'), ('李四', '22', '13511224567'), ('王五', '24', '18833444567')]'''写多行'''writer.writerows(data)csvfile.close() Python读写csv文件示例读写csv文件 cvs_handler.py示例：1.读取inputfile文件内容，并保存到row_contents列表中；2.将row_title和row_contents列表重新写到outputfile文件中；3.执行：python cvs_handler.py personInfo.csv result.csv1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/env python # -*- coding:utf-8 -*-import osimport csvimport sysfrom time import timedef cvs_file_read(filename): if not os.path.isfile(filename): print ("%s is not file." % filename) return None try: csvfile = file(filename, 'rb') reader = csv.reader(csvfile) except: print ("read %s open error." % filename) return None headers = next(reader) row_contents = [] for i, line in enumerate(reader): print i, line row_contents.append(line) csvfile.close() return row_contentsdef csv_file_write(filename, row_title, row_contents): try: csvfile = file(filename, 'wb') writer = csv.writer(csvfile) except: print ("write %s open error." % filename) return writer.writerow(row_title) writer.writerows(row_contents) csvfile.close()def get_opt_init(argv): if len(argv) &lt; 3: print "python cvs_handler.py inputfile outputfile" return None if len(argv) &gt;= 3: inputfile = argv[1] outputfile = argv[2] return inputfile, outputfile if __name__=="__main__" : start = time() inputfile, outputfile = get_opt_init(sys.argv) if not inputfile and outputfile: sys.exit(0) row_contents = cvs_file_read(inputfile) if not row_contents: sys.exit(0) row_title = ["姓名", "年龄", "电话"] csv_file_write(outputfile, row_title, row_contents) print "Time cost %.2fs." % (time() - start) personInfo.csv文件内容如下所示：12345[root@10.127.20.32 cvs]# cat personInfo.csv 姓名,年龄,电话张三,20,18645674567李四,22,13511224567王五,24,18833444567]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础-枚举类]]></title>
    <url>%2F2017%2F12%2F19%2FPython%E5%9F%BA%E7%A1%80-%E6%9E%9A%E4%B8%BE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Python基础枚举类有两种实现方法第一种方法：定义常量，变量名称大写，例如月份：123456JAN = 1FEB = 2MAR = 3...NOV = 11DEC = 12 第二种方法：从Enum派生出自定义枚举类，unique装饰器可以帮助我们检查保证没有重复值，例如星期：1234567891011from enum import Enum, unique @uniqueclass Weekday(Enum): Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 访问枚举类型的若干方法如下，可见在实际使用中既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。123456789101112131415161718192021&gt;&gt;&gt; print (Weekday.Mon)Weekday.Mon&gt;&gt;&gt; print (Weekday['Tue'])Weekday.Tue&gt;&gt;&gt; type(Weekday.Mon)&lt;enum 'Weekday'&gt;&gt;&gt;&gt; print(Weekday.Mon.value)1&gt;&gt;&gt; print(Weekday(1))Weekday.Mon&gt;&gt;&gt; for name, member in Weekday.__members__.items():... print(name, '=&gt;', member)... ('Sun', '=&gt;', &lt;Weekday.Sun: 0&gt;)('Mon', '=&gt;', &lt;Weekday.Mon: 1&gt;)('Tue', '=&gt;', &lt;Weekday.Tue: 2&gt;)('Wed', '=&gt;', &lt;Weekday.Wed: 3&gt;)('Thu', '=&gt;', &lt;Weekday.Thu: 4&gt;)('Fri', '=&gt;', &lt;Weekday.Fri: 5&gt;)('Sat', '=&gt;', &lt;Weekday.Sat: 6&gt;)&gt;&gt;&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础-rpm和yum常用命令]]></title>
    <url>%2F2017%2F10%2F06%2FLinux%E5%9F%BA%E7%A1%80-rpm%E5%92%8Cyum%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[rpm常用命令安装一个rpm包rpm -ivh file.rpm 参数说明：-i ：安装的意思-v ：可视化-h ：显示安装进度另外在安装一个rpm包时常用的附带参数有：–force 强制安装，即使覆盖属于其他包的文件也要安装–nodeps 当要安装的rpm包依赖其他包时，即使其他包没有安装，也要安装这个包 查看包依赖关系rpm -qpR file.rpm 卸载一个rpm包rpm -e file.rpm 查找是否已经安装了某个包rpm -qa | grep htop 查看安装的软件包安装了哪些文件rpm -ql htop 想知道本地文件来自那个软件包rpm -qf /usr/bin/htop rpm包下载网址： https://pkgs.org/ http://rpm.pbone.net https://rpmfind.net/ 参考链接：http://achuan.blog.51cto.com/102/60869 yum常用命令从 repo 中查找某个软件包yum search htop 查看yum安装源中包的版本信息yum info htop 从 repo 中查找哪个包提供了哪个文件yum provides /usr/bin/htop 安装软件包的最新或指定版本yum install [-y] htopyum install [-y] htop-2.0.1-1.el7 查看软件包所有可用的版本yum –showduplicate list htop 卸载软件包yum remove [-y] htop 升级软件包yum update [-y] htop 降级软件包到指定版本（软件包的新版本已经安装）yum downgrade htop-2.0.0-2.el7 删除 yum cacheyum clean all]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++时间结构体与获取函数]]></title>
    <url>%2F2017%2F10%2F06%2FC-C-%E6%97%B6%E9%97%B4%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[时间结构体C/C++中常用的时间结构体有三种：time_t、struct tm、struct timeval。 time_t时间值time_t时间值在time.h中定义如下：1234#ifndef __TIME_T #define __TIME_T typedef long time_t; #endif time_t是一个long型，表示从UTC时间(1970年1月1日00时00分00秒)到当前系统时刻的秒数。使用time()函数可以获取当前系统时间time_t的值。 struct tm时间结构体由于time_t以秒为单位表示可读性差，所以需要一个可以表示当前系统时间（年、月、日、时、分、秒）方式的数据结构struct tm。struct tm结构体也在time.h中定义如下：123456789101112struct tm &#123; int tm_sec; /* 秒,取值范围(0~59)，但当遇到闰秒时则会有60秒的取值。 */ int tm_min; /* 分钟数，取值范围(0-59) */ int tm_hour; /* 小时数，取值范围(0-23) */ int tm_mday; /* 当天在这个月中是第几天，取值范围(1-31) */ int tm_mon; /* 当前月份是第几个月，取值范围(0-11) */ int tm_year; /* 从1900年开始至今的年数，即(Year - 1900)的值 */ int tm_wday; /* 当天在本周是第几天，取值范围(0-6, Sunday = 0) */ int tm_yday; /* 当天在今年是第几天，取值范围(0-365, 1 Jan = 0) */ int tm_isdst; /* 夏令时标记，值大于0表示夏令时生效；等于0表示夏令时失效；小于0表示数据不可用。 */ char *tm_zone; /* 时区名称，根据系统不同可能不被声明或不同全名。 */&#125;; 使用localtime()和gmtime()函数可以把time_t时间值转换成struct tm。 struct timeval结构体由于time_t只能表示秒级时间粒度，而struct timeval结构体可以表示微秒级，其中tv_sec表示当前系统时刻的秒数，tv_usec表示当前系统时刻的微秒数，1秒 = 1000000微秒。struct timeval结构体在time.h中定义如下：1234567/* A time value that is accurate to the nearest microsecond but also has a range of years. */struct timeval&#123; __time_t tv_sec; /* Seconds. */ __suseconds_t tv_usec; /* Microseconds. */&#125;; 使用gettimeofday()函数获取当前系统时间struct timeval结构体的值。 时间获取函数主要介绍四个常用的时间获取函数：time()、gmtime()、localtime()、gettimeofday()。 time()函数头文件：#include &lt;time.h&gt;函数定义：time_t time (time_t *t)功能描述：该函数返回从UTC时间(1970年1月1日00时00分00秒)到当前系统所经过的秒数。返回值：成功则返回秒数，失败则返回((time_t)-1)值，错误原因存于errno中。 gmtime()函数头文件：#include &lt;time.h&gt;函数定义：struct tm *gmtime(time_t const *timep)功能描述：该函数将参数timep指向的time_t时间值转换成以tm结构体表示的世界标准时间UTC。返回值：返回结构体tm代表目前UTC 时间。 localtime()函数头文件：#include &lt;time.h&gt;函数定义：struct tm *localtime(time_t const *timep)功能描述：该函数将参数timep指向的time_t时间值转换成以tm结构体表示的本地时间（如北京时间）。返回值：返回结构体tm代表目前UTC 时间。 说明：以北京时间为例，gmtime()得到的结果比localtime()要提前(早)8小时。 gettimeofday()函数头文件：#include &lt;time.h&gt;函数定义：int gettimeofday (struct timeval *__restrict __tv, __timezone_ptr_t __tz)功能描述：该函数把当前的时间信息存入tv指向的结构体中，把当前时区信息存入tz指向的结构体中，如果tz为NULL则不向tz写入。返回值：成功则返回0，失败则返回-1值，错误原因存于errno中。 时间格式化字符串时间格式化字符串三个常用的函数有： ctime()、asctime()、strftime()、strptime()。 ctime()函数头文件：#include &lt;time.h&gt;函数定义：char *ctime(const time_t *timep)功能描述：将参数timep时间值转换成实际使用的时间日期表示方法。返回值：以字符串形式返回。字符串格式为：”Wed Jun 20 21:00:00 2012\n”。 asctime()函数头文件：#include &lt;time.h&gt;函数定义：char *asctime(const struct tm *tm)功能描述：将参数tm结构体转换成实际使用的时间日期表示方法。返回值：以字符串形式返回。字符串格式为：”Wed Jun 20 21:00:00 2012\n”。 说明：ctime()和asctime()的区别是函数的入参不同，返回的字符串格式化相同。 strftime()函数头文件：#include &lt;time.h&gt;函数定义：size_t strftime(char *s, size_t max, const char *format, const struct tm *tm)功能描述：格式化时间字符串，可以根据format指向字符串中格式命令把tm中保存的时间信息放在s指向的字符串中，最多向s中存放max个字符。返回值：向s指向的字符串中放置的字符数。 strftime()函数的操作有些类似于sprintf()：识别以百分号(%)开始的格式命令集合，格式化输出结果放在一个字符串中。下面仅挑几个常用的来说： 格式化参数 含义 %Y 完整的年数字 %m 月份，如月份是1~9,则数字前填充一个’0’ %d 日子 %F 等同于“%Y-%m-%d” %H 小时数 %M 分钟数 %S 秒数 %_m 月份，如果月份是1~9，则数字前有一个空格填充 %-m 月份，如果月份是1~9，仍只显示该数字 strptime()函数头文件：#include &lt;time.h&gt;函数定义：char *strptime(const char *s, const char *format, struct tm *tm)功能描述：将一个字符串格式化为一个tm结构，功能与strftime相反，根据format指向字符串中格式命令把s指向的字符串转换存储到tm中。返回值：指向转换过程处理的最后一个字符后面的那个字符。 时间代码示例运用上述介绍的结构体和函数编写的C语言代码如下：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;sys/time.h&gt;int main(int argc, char *argv[])&#123; time_t calendar_time; struct tm *tm_local; struct timeval start,end; long dif_sec, dif_usec, j; time(&amp;calendar_time); //calendar_time = time(NULL); printf("calendar_time: %ld\n", calendar_time); tm_local = localtime(&amp;calendar_time); printf("\nlocaltime :year=%d mon=%d mday=%d hour=%d min=%d sec=%d\n",tm_local-&gt;tm_year + 1900, tm_local-&gt;tm_mon + 1, tm_local-&gt;tm_mday, tm_local-&gt;tm_hour, tm_local-&gt;tm_min, tm_local-&gt;tm_sec); printf("asctime: %s\n", asctime(tm_local)); printf("ctime: %s\n", ctime(&amp;calendar_time)); char strtime[128]; strftime(strtime, sizeof(strtime), "%Y-%m-%d %H-%M-%S", tm_local); printf("localtime format: %s\n", strtime); //下面代码可以计算程序部分代码执行的时间(微秒) gettimeofday(&amp;start, NULL); for(int i = 0; i &lt; 10000000; ++i) j = 3.14 * i + 6.28 * i + 0.001 * i; gettimeofday(&amp;end, NULL); dif_sec = end.tv_sec - start.tv_sec; dif_usec = end.tv_usec - start.tv_usec; printf("running time is %ld sec (%ld usec)\n", dif_sec, dif_sec*1000000 + dif_usec); return 0;&#125; 程序运行结果如下：12345678910calendar_time: 1482079700localtime :year=2016 mon=12 mday=18 hour=8 min=48 sec=20asctime: Sun Dec 18 08:48:20 2016ctime: Sun Dec 18 08:48:20 2016localtime format: 2016-12-18 08-48-20running time is 0 sec (97651 usec) 运用strftime和strptime函数编写的C语言代码如下：1234567891011121314151617#include "stdio.h" int main(void) &#123; time_t lt = time(NULL); struct tm* ptr = localtime(&amp;lt); char szBuffer[64] = &#123;0&#125;; const char* pFormat = "The time now is %Y-%m-%d %H:%M:%S"; strftime(szBuffer, 64, pFormat, ptr); printf("%s\n", szBuffer); struct tm tmTemp; char tmBuffer[64] = &#123;0&#125;; strptime(szBuffer, pFormat, &amp;tmTemp);//字符串转换成struct tm结构体 strftime(tmBuffer, 64, "The time just was %Y-%m-%d %H:%M:%S", &amp;tmTemp); printf("%s\n", tmBuffer); return 0; &#125; 程序运行结果如下：12The time now is 2016-12-19 10:39:24The time just was 2016-12-19 10:39:24 参考链接： http://sodino.com/2015/03/15/c-time/ http://blog.csdn.net/yasaken/article/details/7429506]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>Linux系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础-VIM安装教程]]></title>
    <url>%2F2017%2F10%2F06%2FLinux%E5%9F%BA%E7%A1%80-VIM%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[yum安装Vim1.先卸载老的vim1yum remove vim-* -y 2.下载第三方yum源1wget -P /etc/yum.repos.d/ https://copr.fedorainfracloud.org/coprs/mcepl/vim8/repo/epel-7/mcepl-vim8-epel-7.repo 3.安装vim1yum -y install vim-enhanced sudo 4.验证vim版本12345rpm -qa |grep vimvim-enhanced-8.0.0704-1.1.26.el7.centos.x86_64vim-common-8.0.0704-1.1.26.el7.centos.x86_64vim-minimal-8.0.0704-1.1.26.el7.centos.x86_64vim-filesystem-8.0.0704-1.1.26.el7.centos.x86_64 安装过程遇到的依赖问题“libc.so.6 is needed by XXX”解决方法参考：http://www.cnblogs.com/think3t/p/4165102.html rpm包安装Vim1.Vim安装需要的四个rpm包如下：1234vim-filesystem-7.4.629-5.el6_8.1.x86_64.rpmvim-common-7.4.629-5.el6_8.1.x86_64.rpmvim-enhanced-7.4.629-5.el6_8.1.x86_64.rpm vim-minimal-7.4.629-5.el6_8.1.x86_64.rpm 2.登录rpmfind网站，下载vim的rpm包，注：centos只有7.4版本vim包 vim有四个包，下面是按照顺序 3.使用rpm命令安装Vim包，按照1中的顺序依次安装。1rpm -ivh 包名 4.查看vim版本号1vim --version | head 源码安装Vim1.安装依赖1yum -y install ruby perl-devel python-devel ruby-devel perl-ExtUtils-Embed ncurses-devel 2.源码下载源码下载方法一：克隆源码12git clone https://github.com/vim/vim.gitcd vim/ 源码下载方法二：下载压缩包1234wget https://github.com/vim/vim/archive/master.zipunzip master.zipcd vim-mastercd src/ 3.源码编译1234./configure --prefix=/usr/local --enable-multibyte --with-tlib=tinfo --enable-pythoninterp --enable-rubyinterp \--with-ruby-command=/usr/bin/ruby --with-features=hugemakemake install 4.查看vim版本号1vim --version | head]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
</search>
